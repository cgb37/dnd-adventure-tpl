# Plan: Upgrade `dnd-adventure-tpl` into a reusable AI-first D&D campaign template (Iteration 1)

## Context / Decisions (from clarifications)
- Campaign content will live in a **separate repository**.
- Template repo will be **forked per campaign**, and campaign content will be pulled in as a **git submodule**.
- Add `campaign.yml` (per campaign) and a `.env` (for repo + directory values).
- Iteration 1 focus: **separate generated posts/pages from the code** that generates/renders them.
- Iteration 2: build an **automated content generation pipeline** (not in scope for this plan’s implementation steps, but we’ll design for it).
- Keep the current approach where `_data/*.yml` is **auto-generated** (start there).
- Existing content will be **migrated**.
- Each campaign should be a **separate deployable site**, while the template can **accommodate multiple campaigns**.

## Goals (Iteration 1)
1. Separate “template code” (layouts/includes/assets/plugins/scripts) from “campaign content” (posts/pages/images/etc.).
2. Allow a fork of the template to mount one (or more) campaign repositories as submodules.
3. Make it easy to switch which campaign is “active” for local dev/build.
4. Enable each campaign fork to deploy as its own site (e.g., GitHub Pages or any static hosting).
5. Provide a clear migration path from the current monorepo-like structure.

## Non-goals (Iteration 1)
- No automated AI generation pipeline yet (CLI/agent runner/etc. in Iteration 2).
- No generalized plugin system for new content types (later iteration).
- No redesign of UI/theme.

## Proposed Repository Model
### 1) Template Repository (this repo)
Contains:
- Jekyll theme code: `_layouts/`, `_includes/`, `assets/` (shared CSS/JS), `_plugins/`, `_frontmattertpls/`, etc.
- Build/dev tooling: Docker files, scripts.
- Campaign selection + content mounting mechanism.

Does **not** permanently contain:
- A campaign’s `_pages/`, `_posts/`, campaign-specific images, etc. Those live in the campaign content repo(s).

### 2) Campaign Content Repository (separate repo)
Contains:
- Source-of-truth content: `_pages/`, `_posts/`, campaign images, possibly campaign docs.
- `campaign.yml` (metadata and settings).

Derived/generated content:
- `_data/*.yml`, `search.json` should be treated as **build artifacts** (generated by plugins during build) unless you explicitly need them committed for a specific hosting flow.

### 3) How they connect
- Each campaign fork of the template adds the campaign content repo as a submodule.
- The template repo exposes one “active campaign” directory via symlinks (or a copy step) so Jekyll sees content at expected paths.

## Directory Structure (target)
In the **template fork**:

- `campaigns/`
  - `theForsakenCrown/` (git submodule)
  - `icewindDaleRedux/` (git submodule)
  - ...
- `_pages/` -> symlink to `campaigns/<active>/_pages`
- `_posts/` -> symlink to `campaigns/<active>/_posts`
- `assets/images/` -> optional symlink to `campaigns/<active>/assets/images` (or a campaign images folder)
- `campaign.yml` (copied/linked from campaign, or loaded from `campaigns/<active>/campaign.yml`)

Note: symlinks preserve Jekyll’s default expectations without requiring deep Jekyll reconfiguration.

## Configuration
### `campaigns/<name>/campaign.yml` (in the content repo)
Minimum fields:
- `name`: Display name
- `slug`: URL-safe identifier
- `description`: Short summary
- `author` / `credits`
- `version`
- `content_root`: (optional) for future flexibility
- `publish`: flags (draft behavior, etc.)

### `.env` (in the template fork)
For local tooling:
- `CAMPAIGN=<name>` (active campaign)
- `CAMPAIGNS_DIR=campaigns`
- `CONTENT_REPO_URL=<git url>` (optional convenience)
- `CONTENT_SUBMODULE_PATH=campaigns/<name>` (optional)

## Implementation Steps (Iteration 1)
### Phase 0 — Inventory and migration mapping
1. Identify what is “template code” vs “campaign content” in the current repo.
   - Content likely includes: `_pages/**`, `_posts/**`, campaign-specific images in `assets/images/**`, and any campaign-specific `_data` if it’s being committed.
   - Template includes: `_layouts/**`, `_includes/**`, `assets/css`, `assets/js`, `_plugins/**`, `Dockerfile`, etc.
2. Decide what to do with currently committed `_site/` (if it’s being tracked).
   - Prefer treating `_site/` as build output and excluding it.

Deliverable: a migration checklist of folders/files to move.

### Phase 1 — Create the campaign content repository
1. Create a new repo (e.g., `dnd-campaign-<slug>`).
2. Move/copy source content into it:
   - `_pages/`
   - `_posts/`
   - campaign images (e.g., `assets/images/` subset)
3. Add `campaign.yml` at the repo root.
4. Add a `README.md` describing content conventions and review workflow.

Deliverable: content repo ready to be added as a submodule.

### Phase 2 — Add content repo as submodule in the template fork
1. In the template fork, add submodule under `campaigns/<name>`.
2. Add a small script to “activate” a campaign (creates/updates symlinks).
   - Example behavior:
     - Remove existing `_pages`, `_posts`, and campaign image links if they exist.
     - Link them to the selected `campaigns/<name>`.
     - Optionally write `./.active-campaign` for tooling.
3. Update Docker / local dev scripts to call campaign activation on startup.

Deliverable: `CAMPAIGN=<name>` works locally; Jekyll serves the selected campaign.

### Phase 3 — Adjust build artifacts and generated data strategy
1. Decide whether `_data/*.yml` and `search.json` are committed or generated.
   - Recommended: treat as generated outputs; ensure plugins generate them during `jekyll build`.
2. Update ignore rules accordingly:
   - Ignore `_site/`
   - Ignore `_data/*.yml` if generated
   - Ignore `search.json` if generated
3. Validate the site still builds and search still works.

Deliverable: clean separation where content repo holds source content; template repo holds code.

### Phase 4 — Multi-campaign accommodation (still one active at a time)
1. Support multiple submodules under `campaigns/`.
2. Ensure tooling allows switching active campaign quickly:
   - `./scripts/use-campaign <name>` (or similar)
3. Document how to add another campaign:
   - Add submodule
   - Activate campaign
   - Build/deploy

Deliverable: one template fork can host multiple campaigns, each selectable.

### Phase 5 — Migration of existing content
1. Freeze current state (tag or branch).
2. Extract content into the new content repo.
3. Add submodule back into the template fork.
4. Validate build output matches previous behavior.
5. Update documentation for the new workflow.

Deliverable: existing campaign successfully migrated.

## Deployment Approach (per campaign)
- Each campaign is a fork of the template repo configured with a specific content submodule.
- Deploy that fork as a standalone site.
- Optional: For a single template fork with multiple campaigns, deployment can be done by setting `CAMPAIGN=<name>` in CI and building separately per campaign (later iteration if desired).

## Draft Review Workflow (Iteration 1)
- Content repo uses a “draft-first” convention:
  - Either Jekyll drafts (in `_drafts/`) or frontmatter flags like `published: false`.
- Manual review via PRs in the content repo before content is published.

## Acceptance Criteria (Iteration 1)
- Template repo builds with **no campaign content committed directly** (except maybe a minimal example or placeholders).
- A campaign content repo can be added as a submodule and selected as active.
- Local `jekyll serve` shows the active campaign’s pages/posts.
- Switching campaigns changes the rendered content without changing template code.
- Existing campaign can be migrated with a documented set of steps.

## Risks / Open Questions
1. Symlink handling on Windows users (if relevant). If needed, replace symlinks with a copy/sync step.
2. Whether `_data` and `search.json` must be committed for your hosting provider. (If GitHub Pages builds from source, generating at build time is fine; if you publish prebuilt `_site`, you may need a different flow.)
3. How to scope campaign-specific assets that overlap with template assets (naming conventions, directories).

## Iteration 2 Preview (not implemented in Iteration 1)
- Automated generation pipeline that:
  - Writes to the campaign content repo working tree
  - Produces drafts requiring review
  - Supports regeneration/update flows with stable IDs
- Likely shape:
  - A CLI (`scripts/generate`) + prompt templates + structured outputs
  - PR automation against the content repo
