#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}" )/.." && pwd)"

if [[ -f "$ROOT_DIR/.env" ]]; then
  set -a
  # shellcheck source=/dev/null
  . "$ROOT_DIR/.env"
  set +a
fi

usage() {
  cat <<'EOF'
Usage:
  scripts/new-issue-resolution-summary-doc <issueNumber> <issueTitleSlug> [--title "..."] [--base <ref>] [--doc <path>] [--no-diff]

What it does:
  1) Scaffolds a new issue resolution summary doc under docs/ using the naming convention:
    docs/issue-XX-<issue-title-slug>.resolution.md
  2) Appends/updates a diff-style "files changed" list at the bottom, using:
       git diff --name-status <base>...HEAD

Args:
  issueNumber        GitHub issue number (e.g., 3)
  issueTitleSlug     Short kebab-ish issue title slug (e.g., add-chatbot-to-all-view-ports)

Options:
  --title "..."     Human-friendly title for the issue (defaults from slug)
  --base <ref>      Base ref for diff generation (default: main)
  --doc <path>      Write/update this file instead of the default docs filename
  --no-diff         Do not generate/insert the diff section

Examples:
  scripts/new-issue-resolution-summary-doc 3 add-chatbot-to-all-view-ports
  scripts/new-issue-resolution-summary-doc 3 add-chatbot-to-all-view-ports --title "Add Chatbot to All View Ports"
  scripts/new-issue-resolution-summary-doc 3 add-chatbot-to-all-view-ports --base origin/main
EOF
}

if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
  usage
  exit 0
fi

issue="${1:-}"
slug_in="${2:-}"
shift 2 || true

title=""
base_ref="main"
doc_path=""
no_diff="false"

while [[ $# -gt 0 ]]; do
  case "$1" in
    --title)
      title="${2:-}"
      shift 2
      ;;
    --base)
      base_ref="${2:-}"
      shift 2
      ;;
    --doc)
      doc_path="${2:-}"
      shift 2
      ;;
    --no-diff)
      no_diff="true"
      shift
      ;;
    *)
      echo "Unknown argument: $1" >&2
      usage >&2
      exit 2
      ;;
  esac
done

if [[ -z "$issue" || -z "$slug_in" ]]; then
  echo "Missing required args." >&2
  usage >&2
  exit 2
fi

if ! command -v python3 >/dev/null 2>&1; then
  echo "python3 is required." >&2
  exit 2
fi

if ! command -v git >/dev/null 2>&1; then
  echo "git is required." >&2
  exit 2
fi

if [[ ! -d "$ROOT_DIR/.git" ]]; then
  echo "This script must be run from inside the git repo (expected .git at repo root)." >&2
  exit 2
fi

issue_padded="$(python3 -c 'import sys
s=(sys.argv[1] or "").strip()
try:
  n=int(s)
  print(f"{n:02d}" if n < 100 else str(n))
except Exception:
  print(s)
' "$issue")"

slug="$(python3 -c 'import re,sys
s=sys.argv[1].strip().lower()
s=re.sub(r"[^a-z0-9]+","-",s)
s=re.sub(r"-+","-",s).strip("-")
print(s or "issue")
' "$slug_in")"

branch="$(git -C "$ROOT_DIR" rev-parse --abbrev-ref HEAD 2>/dev/null || echo "(unknown)")"

origin_url="$(git -C "$ROOT_DIR" config --get remote.origin.url 2>/dev/null || true)"
repo_http=""
if [[ -n "$origin_url" ]]; then
  # Convert common GitHub remote forms into https://github.com/<owner>/<repo>
  if [[ "$origin_url" =~ ^git@github\.com:([^/]+)/([^\.]+)(\.git)?$ ]]; then
    repo_http="https://github.com/${BASH_REMATCH[1]}/${BASH_REMATCH[2]}"
  elif [[ "$origin_url" =~ ^https?://github\.com/([^/]+)/([^\.]+)(\.git)?$ ]]; then
    repo_http="https://github.com/${BASH_REMATCH[1]}/${BASH_REMATCH[2]}"
  fi
fi

issue_url=""
if [[ -n "$repo_http" ]]; then
  issue_url="$repo_http/issues/$issue"
else
  issue_url="(set manually)"
fi

mkdir -p "$ROOT_DIR/docs"

if [[ -z "$doc_path" ]]; then
  doc_path="$ROOT_DIR/docs/issue-${issue_padded}-${slug}.resolution.md"
elif [[ "$doc_path" != /* ]]; then
  doc_path="$ROOT_DIR/$doc_path"
fi

if [[ -z "$title" ]]; then
  # Best-effort title from slug
  title="$(python3 -c 'import sys
slug=sys.argv[1]
print(" ".join([w.capitalize() for w in slug.split("-")]))
' "$slug")"
fi

date_str="$(date +%Y-%m-%d)"

if [[ ! -f "$doc_path" ]]; then
  cat > "$doc_path" <<EOF
# Issue #$issue_padded — $title (Resolution Summary)

Issue: $issue_url  
Branch: \`$branch\`

## Overview

(2–4 sentences: what changed and where it shows up.)

## Goals (what we built)

- 

## Non-goals

- 

## Why this approach

- 

## Implementation details

### Jekyll / site integration

- 

### Front-end (JS/CSS)

- 

### Backend / API (if applicable)

- 

### Testing

- 

## How to validate

- \`npm run test:ui\`
- \`docker compose up api\` (if required)

## TODO list (execution plan)

- [x] Scaffold doc ($date_str)
- [ ] Fill in Overview/Goals/Non-goals
- [ ] Fill in Implementation details
- [ ] Add validation commands and expected results
- [ ] Review Security considerations
- [ ] Confirm .env vars section
- [ ] Final pass for accuracy

## Security considerations

- (e.g., auth, secret handling, CORS/origin assumptions, XSS safety)

## .env / environment variables added

- None (if true), otherwise list new vars + purpose.

## Diagram (optional)

\`\`\`mermaid
sequenceDiagram
  autonumber
  participant Browser
  participant Jekyll as Jekyll Site
  participant API as LLM API
  Browser->>Jekyll: GET DM page
  Browser->>API: POST /v1/generate/{kind}
  API-->>Browser: JSON response
\`\`\`

## Diff summary (files changed)

\`\`\`diff
(autogenerated by scripts/new-issue-resolution-summary-doc)
\`\`\`
EOF

  echo "Created: $doc_path"
else
  echo "Updating existing doc: $doc_path"
fi

if [[ "$no_diff" == "true" ]]; then
  exit 0
fi

# Compute name-status diff against base.
diff_raw=""
if git -C "$ROOT_DIR" rev-parse --verify "$base_ref" >/dev/null 2>&1; then
  diff_raw="$(git -C "$ROOT_DIR" diff --name-status "$base_ref"...HEAD)"
elif git -C "$ROOT_DIR" rev-parse --verify "origin/$base_ref" >/dev/null 2>&1; then
  diff_raw="$(git -C "$ROOT_DIR" diff --name-status "origin/$base_ref"...HEAD)"
else
  # Fallback: still try using the string as provided (could be origin/main)
  diff_raw="$(git -C "$ROOT_DIR" diff --name-status "$base_ref"...HEAD 2>/dev/null || true)"
fi

formatted="$(python3 -c 'import sys
lines=sys.stdin.read().splitlines()
out=[]
for line in lines:
  if not line.strip():
    continue
  parts=line.split("\t")
  status=parts[0]

  if status.startswith("R") and len(parts) >= 3:
    old, new = parts[1], parts[2]
    out.append(f"- {old}")
    out.append(f"+ {new}")
    continue

  if status.startswith("C") and len(parts) >= 3:
    new = parts[2]
    out.append(f"+ {new}")
    continue

  path = parts[1] if len(parts) > 1 else ""
  if status == "A":
    out.append(f"+ {path}")
  elif status == "D":
    out.append(f"- {path}")
  elif status == "M":
    out.append(f"~ {path}")
  else:
    out.append(f"~ {path}")

sys.stdout.write("\n".join(out).rstrip() + ("\n" if out else ""))
' <<<"$diff_raw")"

python3 - "$doc_path" "$formatted" <<'PY'
import re
from pathlib import Path
import sys

doc_path = Path(sys.argv[1])
diff_lines = sys.argv[2]

text = doc_path.read_text(encoding='utf-8', errors='replace')

header = "## Diff summary (files changed)"
if header not in text:
  text = text.rstrip() + "\n\n" + header + "\n\n```diff\n```\n"

idx = text.find(header)
post = text[idx:]

m = re.search(r"```diff\n([\s\S]*?)\n```", post)
if not m:
  insert_at = idx + len(header)
  text = text[:insert_at] + "\n\n```diff\n```\n" + text[insert_at:]
  idx = text.find(header)
  post = text[idx:]
  m = re.search(r"```diff\n([\s\S]*?)\n```", post)

start = idx + m.start(1)
end = idx + m.end(1)

replacement = diff_lines if diff_lines.strip() else "(no changes detected)\n"
text = text[:start] + replacement + text[end:]

doc_path.write_text(text, encoding='utf-8')
PY
echo "Updated diff summary in: $doc_path"
